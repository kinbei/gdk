#ifndef _THREAD_H_
#define _THREAD_H_

#include <vector>
#include <public.h>
#include <basictype.h>
#include <util/refcount.h>

#ifdef WINDOWS
	typedef HANDLE THREAD_HANDLE;
	typedef unsigned (__stdcall * THREAD_ROUTINE_TYPE)( void * );

	#include <process.h> // for _beginthreadex
#else
	typedef pthread_t THREAD_HANDLE;
	typedef void ( * THREAD_ROUTINE_TYPE)( void * );

	#include <pthread.h> // for pthread_create	
#endif

/**
 * 
 */
class CThread
{
public:
	/**
	 * 
	 */
	CThread()
	{
		m_hThread = 0;
	}
	/**
	 * 
	 */
	virtual ~CThread()
	{

	}
	/**
	 * 
	 */
	int32 initialize( THREAD_ROUTINE_TYPE pRoutine, void* pArglist )
	{
		m_pRoutine = pRoutine;

		m_pArglist = pArglist;

#ifdef WINDOWS
		unsigned nThreadID = 0;

		// It is safer to use _beginthreadex than _beginthread. 
		// If the thread generated by _beginthread exits quickly, 
		// the handle returned to the caller of _beginthread might be invalid or, worse, point to another thread.
		m_hThread = (HANDLE)_beginthreadex( NULL, 0, ThreadRoutine, (void*)this, 0, &nThreadID );

		// _beginthreadex returns 0 on an error, in which case errno and _doserrno are set.
		if ( m_hThread == NULL )
			return _doserrno;
#else
		int32 nRetCode = pthread_create(&this->m_hThread, NULL, ThreadRoutine, (void*)this );
		if ( nRetCode != 0 )
		{
			this->m_hThread = 0;
			return nRetCode;
		}
#endif

		return 0;
	}
	/**
	 * Waiting for the end of thread
	 */
	void finalize()
	{
#ifdef WINDOWS
		if ( m_hThread != NULL )
		{
			WaitForSingleObject( m_hThread, INFINITE );

			// Destroy the thread object.
			CloseHandle( m_hThread );
		}
#else
		if ( m_hThread != 0 )
			(void) pthread_join( m_hThread, NULL );
#endif
	}
	/**
	 * 
	 */
#ifdef WINDOWS
	static unsigned __stdcall ThreadRoutine( void * pArglist )
#else
	static void* ThreadRoutine( void * pArglist )
#endif
	{
		CThread* pThis = (CThread*)pArglist;

		// 
		pThis->m_pRoutine( pThis->m_pArglist );

#ifdef WINDOWS
		// A thread created with _beginthreadex is terminated by a call to _endthreadex.
		_endthreadex( 0 );
		return 0;
#else

#endif
	}

private:
	// Object of the thread
	THREAD_HANDLE m_hThread;
	//
	THREAD_ROUTINE_TYPE m_pRoutine;
	//
	void* m_pArglist;
};

typedef TRefCountToObj<CThread> CThreadPtr;

/**
 * 
 */
class CThreadFactory
{
public:
	/**
	 * 
	 */
	CThreadFactory()
	{

	}
	/**
	 * 
	 */
	virtual ~CThreadFactory()
	{
		
	}
	/**
	 * 
	 */
	static void finalize()
	{
		// Waiting for the end of every thread
		std::vector<CThreadPtr>::iterator iter_t;
		for ( iter_t = m_vecThread.begin(); iter_t != m_vecThread.end(); iter_t++ )
		{
			CThreadPtr pThread = *iter_t;
			pThread->finalize();
		}
	}
	/**
	 * 
	 */
	static CThreadPtr createThread()
	{
		CThreadPtr pThread = new CThread();
		m_vecThread.push_back( pThread );

		return pThread;
	}

private:
	//
	static std::vector<CThreadPtr> m_vecThread;
};


#endif
